# Implementation Plan: Backend API for Todo Application

**Branch**: `001-backend-api` | **Date**: 2026-02-09 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-backend-api/spec.md`

## Summary

Implement a secure, stateless REST API backend for the Todo application using Python FastAPI, SQLModel ORM, and Neon Serverless PostgreSQL. The backend enforces JWT-based authentication on all endpoints, maintains strict user isolation, and provides six REST endpoints for task management (list, create, read, update, delete, toggle completion). The implementation prioritizes security through JWT verification, user_id filtering on all queries, and production-safe error handling without exposing sensitive information.

**Primary Requirement**: Build a stateless backend API that verifies JWT tokens from Better Auth, connects exclusively to Neon PostgreSQL, and enforces user isolation on all task operations.

**Technical Approach**: Use FastAPI's dependency injection for JWT verification middleware, SQLModel for database schema definition with indexed foreign keys, and repository pattern for enforcing user_id filtering on all database queries.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: FastAPI 0.115+, SQLModel 0.0.24+, psycopg[binary] 3.1+, python-jose[cryptography] 3.3+ (JWT), pydantic 2.0+, uvicorn[standard] 0.27+
**Storage**: Neon Serverless PostgreSQL (via DATABASE_URL environment variable)
**Testing**: pytest 8.0+, pytest-asyncio 0.23+, httpx 0.27+ (async test client)
**Target Platform**: Linux server (containerized deployment via Docker)
**Project Type**: Web API (backend only - monorepo structure)
**Performance Goals**: <500ms p95 latency for API requests, support 100+ concurrent authenticated requests
**Constraints**: Stateless architecture (no server-side sessions), DATABASE_URL required at startup, JWT verification on every request, user_id filtering on all queries
**Scale/Scope**: Phase II MVP - 6 REST endpoints, 3 database tables (tasks, users, sessions), single backend service

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

1. ✅ **Spec-Driven Development**: All implementation originates from approved spec.md - no inferred requirements
2. ✅ **Agentic Dev Stack Workflow**: Following sequence - Spec (complete) → Plan (this document) → Tasks (next) → Implement
3. ✅ **No Manual Coding**: All code will be generated by Claude Code following tasks
4. ✅ **Technology Stack Compliance**: Using locked stack - FastAPI, SQLModel, Neon PostgreSQL, Better Auth (JWT verification)
5. ✅ **Repository Structure Authority**: Backend code in /backend directory only, specs in /specs/001-backend-api
6. ✅ **Authentication & Security**: JWT authentication enforced on all endpoints with user isolation via user_id filtering

**Gate Status**: ✅ PASS - All constitutional requirements satisfied

## Project Structure

### Documentation (this feature)

```text
specs/001-backend-api/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file (implementation plan)
├── research.md          # Phase 0 output (technical decisions)
├── data-model.md        # Phase 1 output (database schema design)
├── quickstart.md        # Phase 1 output (setup and run instructions)
├── contracts/           # Phase 1 output (API contracts)
│   └── openapi.yaml     # OpenAPI 3.0 specification
├── checklists/          # Quality validation
│   └── requirements.md  # Spec quality checklist (complete)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/
├── app/
│   ├── __init__.py
│   ├── main.py              # FastAPI application entry point
│   ├── config.py            # Configuration and environment variables
│   ├── database.py          # Database connection and session management
│   ├── models/              # SQLModel database models
│   │   ├── __init__.py
│   │   ├── user.py          # User model
│   │   ├── task.py          # Task model
│   │   └── session.py       # Session model
│   ├── schemas/             # Pydantic request/response schemas
│   │   ├── __init__.py
│   │   ├── task.py          # Task schemas (create, update, response)
│   │   └── error.py         # Error response schemas
│   ├── repositories/        # Data access layer with user_id filtering
│   │   ├── __init__.py
│   │   └── task.py          # Task repository (enforces user isolation)
│   ├── routers/             # API route handlers
│   │   ├── __init__.py
│   │   └── tasks.py         # Task endpoints
│   ├── dependencies/        # FastAPI dependencies
│   │   ├── __init__.py
│   │   ├── auth.py          # JWT verification and user extraction
│   │   └── database.py      # Database session dependency
│   └── core/                # Core utilities
│       ├── __init__.py
│       ├── security.py      # JWT verification logic
│       └── exceptions.py    # Custom exception handlers
├── tests/
│   ├── __init__.py
│   ├── conftest.py          # Pytest fixtures
│   ├── test_auth.py         # Authentication tests
│   ├── test_tasks.py        # Task endpoint tests
│   └── test_user_isolation.py  # Security tests for cross-user access
├── alembic/                 # Database migrations (if needed)
│   ├── versions/
│   └── env.py
├── .env.example             # Example environment variables
├── requirements.txt         # Python dependencies
├── Dockerfile               # Container definition
└── README.md                # Backend setup instructions
```

**Structure Decision**: Web application structure (Option 2) selected because this is a backend API service in a monorepo with separate frontend. All backend code resides in `/backend` directory to maintain separation from frontend code in `/frontend` directory, as mandated by the constitution.

## Complexity Tracking

> **No violations** - All constitutional requirements are satisfied without exceptions.

## Phase 0: Research & Technical Decisions

**Objective**: Resolve technical unknowns and document architectural decisions for JWT verification, database connection management, and user isolation enforcement.

**Key Research Areas**:

1. **JWT Verification Strategy**
   - Research: Better Auth JWT token structure and claims
   - Decision needed: Which JWT library (python-jose vs PyJWT)
   - Decision needed: JWT claim names for user_id (sub, user_id, or custom)
   - Decision needed: Token expiration handling and error messages

2. **Database Connection Management**
   - Research: Neon PostgreSQL connection pooling best practices
   - Research: SQLModel async vs sync engine for FastAPI
   - Decision needed: Connection pool size and timeout settings
   - Decision needed: Startup connection validation strategy

3. **User Isolation Enforcement Pattern**
   - Research: Repository pattern vs direct SQLModel queries
   - Decision needed: Where to enforce user_id filtering (middleware, dependency, or repository)
   - Decision needed: How to prevent accidental cross-user queries

4. **Database Migration Strategy**
   - Research: SQLModel.metadata.create_all() vs Alembic migrations
   - Decision needed: Migration tool for Phase II (simple) vs Phase III+ (complex)
   - Decision needed: Schema versioning approach

5. **Error Handling and Logging**
   - Research: FastAPI exception handlers for production
   - Decision needed: Logging format and sensitive data filtering
   - Decision needed: Error response schema standardization

**Dependencies**: None (research phase)

**Risks**:
- Risk: Better Auth JWT format may differ from assumptions
- Mitigation: Document actual JWT structure in research.md for validation during implementation

**Output**: `research.md` with documented decisions and rationale for each area

## Phase 1: Design & Contracts

**Objective**: Design database schema, define API contracts, and create data models based on specification requirements and research decisions.

**Prerequisites**: Phase 0 research.md complete

### 1.1 Database Schema Design

**Task**: Extract entities from spec and design SQLModel schemas

**Entities from Specification**:

1. **User Model** (FR-027)
   - id: UUID (primary key)
   - username: str (unique, indexed)
   - email: str (unique, indexed)
   - password: str (hashed)
   - created_at: datetime

2. **Task Model** (FR-026)
   - id: UUID (primary key)
   - title: str (required, max 255 chars)
   - description: str (optional, max 2000 chars)
   - completed: bool (default False)
   - priority: Enum['low', 'medium', 'high'] | None
   - due_date: date | None (ISO 8601)
   - tags: List[str] (PostgreSQL ARRAY)
   - recurrence_pattern: str | None
   - user_id: UUID (foreign key to users.id, indexed, non-null)
   - created_at: datetime
   - updated_at: datetime

3. **Session Model** (FR-028)
   - id: UUID (primary key)
   - user_id: UUID (foreign key to users.id)
   - created_at: datetime
   - expires_at: datetime

**Relationships**:
- User → Tasks (one-to-many)
- User → Sessions (one-to-many)

**Indexes** (FR-029):
- tasks.user_id (critical for query performance)
- users.username (for lookups)
- users.email (for lookups)

**Validation Rules** (FR-032 to FR-036):
- title: non-empty, strip whitespace, max 255 chars
- priority: must be 'low', 'medium', 'high', or None
- due_date: valid ISO 8601 date or None
- tags: array of strings
- recurrence_pattern: string or None

**Output**: `data-model.md` with complete schema definitions, relationships, and validation rules

### 1.2 API Contract Definition

**Task**: Generate OpenAPI 3.0 specification from functional requirements

**Endpoints** (FR-020 to FR-025):

1. **GET /api/{user_id}/tasks**
   - Summary: List all tasks for authenticated user
   - Security: Bearer JWT
   - Parameters: user_id (path, ignored - uses JWT user_id)
   - Response 200: Array of Task objects
   - Response 401: Unauthorized (invalid/missing JWT)

2. **POST /api/{user_id}/tasks**
   - Summary: Create new task
   - Security: Bearer JWT
   - Parameters: user_id (path, ignored)
   - Request Body: TaskCreate schema (title, description, priority, due_date, tags, recurrence_pattern)
   - Response 201: Created Task object
   - Response 400: Bad Request (validation error)
   - Response 401: Unauthorized

3. **GET /api/{user_id}/tasks/{id}**
   - Summary: Get specific task
   - Security: Bearer JWT
   - Parameters: user_id (path, ignored), id (path, UUID)
   - Response 200: Task object
   - Response 401: Unauthorized
   - Response 404: Not Found (task doesn't exist or doesn't belong to user)

4. **PUT /api/{user_id}/tasks/{id}**
   - Summary: Update task
   - Security: Bearer JWT
   - Parameters: user_id (path, ignored), id (path, UUID)
   - Request Body: TaskUpdate schema (all fields optional)
   - Response 200: Updated Task object
   - Response 400: Bad Request
   - Response 401: Unauthorized
   - Response 404: Not Found

5. **DELETE /api/{user_id}/tasks/{id}**
   - Summary: Delete task
   - Security: Bearer JWT
   - Parameters: user_id (path, ignored), id (path, UUID)
   - Response 204: No Content
   - Response 401: Unauthorized
   - Response 404: Not Found

6. **PATCH /api/{user_id}/tasks/{id}/complete**
   - Summary: Toggle task completion status
   - Security: Bearer JWT
   - Parameters: user_id (path, ignored), id (path, UUID)
   - Response 200: Updated Task object
   - Response 401: Unauthorized
   - Response 404: Not Found

**Error Responses** (FR-038 to FR-042):
- 400: `{"detail": "Validation error message"}`
- 401: `{"detail": "Could not validate credentials"}`
- 404: `{"detail": "Task not found"}`
- 500: `{"detail": "Internal server error"}` (no sensitive info)

**Output**: `contracts/openapi.yaml` with complete API specification

### 1.3 Quickstart Documentation

**Task**: Create setup and run instructions for local development

**Content**:
1. Prerequisites (Python 3.11+, Neon account)
2. Environment setup (DATABASE_URL, BETTER_AUTH_SECRET)
3. Dependency installation (pip install -r requirements.txt)
4. Database initialization (schema creation)
5. Running the server (uvicorn app.main:app --reload)
6. Testing endpoints (curl examples with JWT)
7. Running tests (pytest)

**Output**: `quickstart.md` with step-by-step instructions

### 1.4 Agent Context Update

**Task**: Update Claude Code agent context with backend technology stack

**Action**: Run `.specify/scripts/powershell/update-agent-context.ps1 -AgentType claude`

**Context to Add**:
- FastAPI project structure and patterns
- SQLModel database models and relationships
- JWT verification with python-jose
- Repository pattern for user isolation
- Neon PostgreSQL connection management

**Output**: Updated agent context file with backend-specific knowledge

**Dependencies**: research.md, data-model.md, contracts/openapi.yaml complete

**Risks**:
- Risk: OpenAPI spec may not capture all validation rules
- Mitigation: Include detailed validation rules in data-model.md and reference in tasks

## Phase 2: Implementation Breakdown

**Objective**: Break down implementation into ordered, testable tasks

**Note**: This phase is executed by `/sp.tasks` command, NOT by `/sp.plan`. The plan provides guidance on how tasks should be structured.

**Recommended Task Structure**:

### Task Group 1: Foundation (No Dependencies)
1. Project setup and dependencies
2. Configuration management (DATABASE_URL, BETTER_AUTH_SECRET)
3. Database connection and session management
4. SQLModel schema definitions

### Task Group 2: Authentication (Depends on Group 1)
5. JWT verification utility
6. Authentication dependency (extract user_id from JWT)
7. Authentication tests (valid/invalid/expired tokens)

### Task Group 3: Data Access (Depends on Group 1, 2)
8. Task repository with user_id filtering
9. Repository tests (user isolation verification)

### Task Group 4: API Endpoints (Depends on Group 1, 2, 3)
10. Task router with all 6 endpoints
11. Request/response schemas
12. Endpoint tests (CRUD operations)
13. Security tests (cross-user access prevention)

### Task Group 5: Error Handling & Production Readiness (Depends on All)
14. Custom exception handlers
15. Production logging configuration
16. Startup validation (DATABASE_URL check)
17. Health check endpoint
18. Integration tests (end-to-end flows)

**Task Ordering Principle**: Each task must be independently testable and should not break existing functionality. Tasks are ordered by dependency - foundation first, then authentication, then data access, then endpoints, then production readiness.

## Architecture Decisions

### Decision 1: Repository Pattern for User Isolation

**Context**: Need to enforce user_id filtering on all database queries to prevent cross-user data access (FR-015, FR-016).

**Options Considered**:
1. Direct SQLModel queries in route handlers
2. Middleware-based query filtering
3. Repository pattern with user_id parameter

**Decision**: Use repository pattern with user_id parameter

**Rationale**:
- Centralizes user_id filtering logic in one place
- Makes it impossible to accidentally query without user_id
- Easier to test user isolation independently
- Follows separation of concerns (routes handle HTTP, repositories handle data)

**Trade-offs**:
- Adds abstraction layer (more files)
- Requires passing user_id to all repository methods
- Accepted because security is critical and abstraction prevents bugs

### Decision 2: Synchronous SQLModel Engine

**Context**: Need to choose between async and sync database operations with SQLModel and Neon PostgreSQL.

**Options Considered**:
1. Async engine with asyncpg driver
2. Sync engine with psycopg driver

**Decision**: Use sync engine with psycopg driver (defer async to Phase III+)

**Rationale**:
- SQLModel documentation primarily uses sync patterns
- Simpler implementation for Phase II MVP
- Neon supports both sync and sync connections
- Performance requirements (<500ms p95) achievable with sync
- Can migrate to async in future phase if needed

**Trade-offs**:
- Sync operations may block under very high load
- Accepted for Phase II because 100 concurrent requests is achievable with sync

### Decision 3: SQLModel.metadata.create_all() for Schema Creation

**Context**: Need to decide on database migration strategy (FR-026 to FR-031, Assumption 10).

**Options Considered**:
1. SQLModel.metadata.create_all() on startup
2. Alembic migrations from the start
3. Manual SQL scripts

**Decision**: Use SQLModel.metadata.create_all() for Phase II, plan Alembic for Phase III+

**Rationale**:
- Phase II is MVP with stable schema
- No existing data to migrate
- Simpler setup for initial development
- Alembic can be added later when schema evolution is needed

**Trade-offs**:
- No migration history tracking
- Schema changes require manual intervention
- Accepted for Phase II because schema is stable and documented in spec

### Decision 4: python-jose for JWT Verification

**Context**: Need to verify JWT tokens issued by Better Auth (FR-007 to FR-014).

**Options Considered**:
1. python-jose[cryptography]
2. PyJWT
3. authlib

**Decision**: Use python-jose[cryptography]

**Rationale**:
- Well-documented in FastAPI security tutorials
- Supports multiple JWT algorithms
- Includes cryptography backend for security
- Active maintenance and community support

**Trade-offs**:
- Slightly larger dependency footprint than PyJWT
- Accepted because security and compatibility are priorities

### Decision 5: Dependency Injection for JWT Verification

**Context**: Need to verify JWT on every request and extract user_id (FR-007, FR-008).

**Options Considered**:
1. Middleware-based JWT verification
2. Dependency injection per endpoint
3. Decorator-based authentication

**Decision**: Use FastAPI dependency injection with `Depends(get_current_user)`

**Rationale**:
- Native FastAPI pattern for authentication
- Automatic OpenAPI documentation integration
- Easy to test (can override dependencies in tests)
- Clear and explicit in route definitions

**Trade-offs**:
- Must add dependency to every endpoint
- Accepted because explicitness prevents accidental unprotected endpoints

## Security Considerations

### User Isolation Enforcement

**Strategy**: Multi-layer defense

1. **Layer 1 - JWT Verification**: Extract user_id from JWT token, never trust client input (FR-008, FR-018)
2. **Layer 2 - Repository Filtering**: All repository methods require user_id parameter and filter queries (FR-016)
3. **Layer 3 - 404 for Cross-User Access**: Return 404 instead of 403 to avoid information leakage (FR-017)

**Testing**: Comprehensive security tests must verify that User A cannot access User B's tasks through any endpoint or parameter manipulation.

### Sensitive Data Protection

**Strategy**: Production-safe error handling and logging

1. **Error Messages**: Never expose connection strings, stack traces, or internal IDs (FR-019, FR-042)
2. **Logging**: Filter out passwords, JWT tokens, and connection strings (FR-045)
3. **Startup Validation**: Fail fast if DATABASE_URL missing to prevent silent failures (FR-005)

### JWT Token Handling

**Strategy**: Stateless verification with shared secret

1. **Secret Management**: BETTER_AUTH_SECRET must match frontend (Assumption 1, Risk 1)
2. **Token Expiration**: Verify exp claim and return 401 for expired tokens (FR-010)
3. **Signature Verification**: Verify JWT signature on every request (FR-011)
4. **Claim Extraction**: Extract user_id from standard claim (sub or custom) (Assumption 1)

## Performance Considerations

### Database Query Optimization

**Strategy**: Indexed queries and connection pooling

1. **Indexes**: Create index on tasks.user_id for fast filtering (FR-029)
2. **Connection Pool**: Configure appropriate pool size for Neon (research in Phase 0)
3. **Query Patterns**: Use SQLModel select() with filters, avoid N+1 queries

**Target**: <500ms p95 latency for API requests (Success Criteria SC-004)

### Concurrent Request Handling

**Strategy**: Uvicorn with multiple workers

1. **Workers**: Configure uvicorn workers based on CPU cores
2. **Connection Pool**: Size pool to handle concurrent requests
3. **Stateless Design**: No shared state between requests enables horizontal scaling

**Target**: Support 100+ concurrent authenticated requests (Success Criteria SC-009)

## Testing Strategy

### Test Levels

1. **Unit Tests**: Individual functions and utilities (JWT verification, validation)
2. **Integration Tests**: Repository layer with test database
3. **API Tests**: Endpoint behavior with FastAPI TestClient
4. **Security Tests**: Cross-user access prevention, authentication enforcement
5. **End-to-End Tests**: Complete user flows (create → read → update → delete)

### Critical Test Scenarios

1. **Authentication**:
   - Valid JWT token → request succeeds
   - Missing JWT token → 401 Unauthorized
   - Expired JWT token → 401 Unauthorized
   - Invalid JWT signature → 401 Unauthorized

2. **User Isolation**:
   - User A creates task → User B cannot read it (404)
   - User A creates task → User B cannot update it (404)
   - User A creates task → User B cannot delete it (404)
   - URL user_id parameter is ignored, JWT user_id is used

3. **Data Validation**:
   - Empty title → 400 Bad Request
   - Invalid priority → 400 Bad Request
   - Invalid date format → 400 Bad Request
   - Valid data → task created successfully

4. **CRUD Operations**:
   - Create task → returns task with ID
   - List tasks → returns only user's tasks
   - Get task → returns correct task
   - Update task → changes persisted
   - Delete task → task removed, subsequent get returns 404
   - Toggle completion → completed status toggled

### Test Data Strategy

1. **Fixtures**: Create test users and JWT tokens in conftest.py
2. **Isolation**: Each test uses separate test data, no shared state
3. **Cleanup**: Tests clean up created data or use transaction rollback

## Deployment Considerations

### Environment Variables

**Required**:
- `DATABASE_URL`: Neon PostgreSQL connection string (FR-004)
- `BETTER_AUTH_SECRET`: Shared secret for JWT verification (FR-014)

**Optional**:
- `LOG_LEVEL`: Logging verbosity (default: INFO)
- `CORS_ORIGINS`: Allowed frontend origins (default: localhost)

### Startup Validation

**Checks** (FR-005):
1. DATABASE_URL is set → fail if missing
2. BETTER_AUTH_SECRET is set → fail if missing
3. Database connection successful → fail if cannot connect
4. Schema exists → create if missing (SQLModel.metadata.create_all)

### Docker Containerization

**Strategy**: Multi-stage build for production

1. **Base Image**: python:3.11-slim
2. **Dependencies**: Install from requirements.txt
3. **Application**: Copy app/ directory
4. **Entrypoint**: uvicorn with production settings
5. **Health Check**: GET /health endpoint

## Risks and Mitigations

### Risk 1: JWT Secret Mismatch (from spec)
**Impact**: High - complete authentication failure
**Mitigation**:
- Document BETTER_AUTH_SECRET requirement in quickstart.md
- Add startup validation to verify secret is set
- Include test with known JWT token to validate secret

### Risk 2: Neon Connection Failures (from spec)
**Impact**: High - system unavailable
**Mitigation**:
- Implement connection retry logic with exponential backoff
- Fail fast on startup if connection unavailable
- Log connection errors without exposing connection string

### Risk 3: Cross-User Data Leakage (from spec)
**Impact**: Critical - security breach
**Mitigation**:
- Enforce user_id filtering at repository layer
- Comprehensive security tests for all endpoints
- Code review all query logic before implementation

### Risk 4: SQLModel Async Compatibility
**Impact**: Medium - may need refactoring for async
**Mitigation**:
- Use sync engine for Phase II (decision documented)
- Design repository interface to support future async migration
- Document async migration path in research.md

### Risk 5: Database Schema Evolution
**Impact**: Medium - potential downtime for schema changes
**Mitigation**:
- Document current schema in data-model.md
- Plan Alembic migration for Phase III+
- Keep Phase II schema stable per specification

## Success Criteria Mapping

This plan addresses all success criteria from the specification:

- **SC-001** (Data Integrity): Repository pattern with transactions ensures CRUD integrity
- **SC-002** (User Isolation): Multi-layer defense (JWT + repository filtering + 404 responses)
- **SC-003** (Authentication): JWT verification dependency on all endpoints
- **SC-004** (Performance): Indexed queries, connection pooling, <500ms target
- **SC-005** (Database Connection): Startup validation ensures Neon connection
- **SC-006** (Fail Fast): Startup validation fails if DATABASE_URL missing
- **SC-007** (Error Messages): Pydantic validation with clear error messages
- **SC-008** (Stateless): No server-side sessions, JWT verification only
- **SC-009** (Concurrency): Uvicorn workers, connection pooling for 100+ requests
- **SC-010** (No Sensitive Data): Custom exception handlers filter sensitive info

## Next Steps

1. **Execute Phase 0**: Create research.md with technical decisions
2. **Execute Phase 1**: Create data-model.md, contracts/openapi.yaml, quickstart.md
3. **Run `/sp.tasks`**: Generate detailed task breakdown from this plan
4. **Implement**: Execute tasks in order with tests for each

**Completion Criteria**: Plan is complete and unambiguous. Ready for `/sp.tasks` command to generate implementation tasks.
